---
layout: default
title: Public API
parent: Reference
nav_order: 1
---
= API Reference

Complete reference for Vectory's public API.

== Format Classes

=== Vectory::Image

Base class for all image types.

[source,ruby]
----
# Factory method (auto-detects format)
image = Vectory::Image.from_path("diagram.eps")
----

**Methods**:

* `Vectory::Image.from_path(path)` - Load from file path
* `Vectory::Image.from_content(content)` - Load from content string
* `Vectory::Image.from_datauri(uri)` - Load from data URI

=== Vectory::Vector

Abstract base class for vector formats. Inherits from `Vectory::Image`.

[source,ruby]
----
# Conversion methods available on all vector formats
vector.to_eps
vector.to_ps
vector.to_emf
vector.to_svg
vector.to_pdf
----

=== Vectory::Eps

Encapsulated PostScript format.

[source,ruby]
----
# Load EPS
eps = Vectory::Eps.from_path("diagram.eps")

# Convert to other formats
svg = eps.to_svg
pdf = eps.to_pdf
ps = eps.to_ps
----

**Key Methods**:

* `Vectory::Eps.from_path(path)` - Load from file
* `Vectory::Eps.from_content(content)` - Load from string
* `Vectory::Eps.from_datauri(uri)` - Load from data URI
* `#dimensions` - Get [width, height] in points
* `#to_svg` - Convert to SVG
* `#to_pdf` - Convert to PDF
* `#to_eps` - Return self
* `#to_ps` - Convert to PS
* `#to_emf` - Convert to EMF (via SVG)
* `#write(path = nil)` - Write to file
* `#content` - Raw file content
* `#initial_path` - Original file location
* `#path` - Current write location

=== Vectory::Ps

PostScript format. Same API as `Vectory::Eps`.

[source,ruby]
----
ps = Vectory::Ps.from_path("document.ps")
svg = ps.to_svg
----

=== Vectory::Svg

Scalable Vector Graphics format.

[source,ruby]
----
svg = Vectory::Svg.from_path("drawing.svg")
eps = svg.to_eps
pdf = svg.to_pdf
----

=== Vectory::Emf

Enhanced Metafile format.

[source,ruby]
----
emf = Vectory::Emf.from_path("chart.emf")
svg = emf.to_svg
----

Uses the emf2svg gem for conversion.

=== Vectory::Pdf

PDF format (used internally as intermediate format).

[source,ruby]
----
pdf = Vectory::Pdf.from_path("document.pdf")
svg = pdf.to_svg
----

## Factory Methods

All format classes support these factory methods:

### from_path

Load from file path:

[source,ruby]
----
eps = Vectory::Eps.from_path("diagram.eps")
----

### from_content

Load from content string:

[source,ruby]
----
content = File.read("diagram.eps")
eps = Vectory::Eps.from_content(content)
----

### from_datauri

Load from data URI:

[source,ruby]
----
uri = "data:image/svg+xml;base64,PHN2Zy..."
svg = Vectory::Svg.from_datauri(uri)
----

### from_node

Load from XML node (Metanorma integration):

[source,ruby]
----
# Used internally by Metanorma
svg = Vectory::Svg.from_node(xml_node)
----

## Conversion Methods

All format classes support conversion to any other format:

[source,ruby]
----
# Convert EPS to SVG
svg = Vectory::Eps.from_path("diagram.eps").to_svg

# Convert SVG to EPS
eps = Vectory::Svg.from_path("diagram.svg").to_eps

# Convert EMF to SVG
svg = Vectory::Emf.from_path("chart.emf").to_svg
----

## Properties

### content

Raw file content as string:

[source,ruby]
----
eps = Vectory::Eps.from_path("diagram.eps")
raw = eps.content
----

### initial_path

Original file location (read-only):

[source,ruby]
----
eps = Vectory::Eps.from_path("diagram.eps")
puts eps.initial_path  # => "diagram.eps"
----

### path

Current file location (raises error if not written):

[source,ruby]
----
eps = Vectory::Eps.from_path("diagram.eps")

# WRONG: raises error
puts eps.path  # => NotWrittenToDiskError

# CORRECT: write first
eps.write("output.eps")
puts eps.path  # => "output.eps"
----

### dimensions

Image dimensions as [width, height]:

[source,ruby]
----
eps = Vectory::Eps.from_path("diagram.eps")
width, height = eps.dimensions
puts "Size: #{width}x#{height}"
----

## Methods

### write

Write image to file:

[source,ruby]
----
# Write to specific path
svg.write("output.svg")

# Write to temp directory
svg.write
----

Returns the path to the written file.

## Utility Classes

### Vectory::FileMagic

Format detection utilities:

[source,ruby]
----
# Detect format from content
content = File.read("unknown_file")
format = Vectory::FileMagic.detect_format(content)

# Format symbols: :eps, :ps, :emf, :svg, :unknown
----

### Vectory::InkscapeWrapper

Singleton wrapper for Inkscape:

[source,ruby]
----
inkscape = Vectory::InkscapeWrapper.instance

# Check availability
inkscape.available?

# Get version
inkscape.version

# Get executable path
inkscape.executable

# Check if modern version (1.x)
inkscape.modern?
----

### Vectory::GhostscriptWrapper

Singleton wrapper for Ghostscript:

[source,ruby]
----
gs = Vectory::GhostscriptWrapper.instance

# Check availability
gs.available?

# Get executable path
gs.executable
----

## Error Classes

[source,ruby]
----
Vectory::Error                  # Base error
    ├── SystemCallError         # External tool failures
    ├── NotWrittenToDiskError   # Path access before write
    ├── ParsingError           # Content parsing failures
    ├── InkscapeNotFoundError  # Inkscape unavailable
    ├── ConversionError        # Conversion failures
    └── InkscapeQueryError     # Dimension query failures
----

## Usage Examples

=== Basic Conversion

[source,ruby]
----
require 'vectory'

# EPS to SVG
svg = Vectory::Eps.from_path("diagram.eps").to_svg
svg.write("diagram.svg")
----

=== Batch Processing

[source,ruby]
----
Dir["diagrams/*.eps"].each do |eps_file|
  svg = Vectory::Eps.from_path(eps_file).to_svg
  svg.write(eps_file.sub(".eps", ".svg"))
end
----

=== Error Handling

[source,ruby]
----
begin
  svg = Vectory::Eps.from_path("diagram.eps").to_svg
rescue Vectory::InkscapeNotFoundError => e
  puts "Inkscape not found: #{e.message}"
rescue Vectory::ConversionError => e
  puts "Conversion failed: #{e.message}"
end
----

=== Dimension query

[source,ruby]
----
eps = Vectory::Eps.from_path("diagram.eps")
width, height = eps.dimensions
puts "Dimensions: #{width}x#{height}"
----

== SVG mapping

Integrates SVG content into XML documents with ID disambiguation for multi-document scenarios.

=== Vectory::SvgMapping

Processes XML documents containing `<svgmap>` elements, extracting and integrating SVG content.

[source,ruby]
----
# Basic usage
xml_string = Vectory::SvgMapping.from_path("doc.xml").to_xml

# With ID suffix for cross-document uniqueness
mapping = Vectory::SvgMapping.new(doc, "", id_suffix: "_ISO_17301-1_2016")
xml_string = mapping.call.to_xml
----

**Factory methods**:

* `Vectory::SvgMapping.from_path(path)` - Load from file path
* `Vectory::SvgMapping.from_xml(xml)` - Load from XML string
* `Vectory::SvgMapping.new(doc, local_directory, id_suffix: nil)` - Direct instantiation

**Parameters**:

* `doc` - Nokogiri XML Document containing svgmap elements
* `local_directory` - Directory for resolving relative file paths
* `id_suffix` - Optional suffix for cross-document ID uniqueness (e.g., "_ISO_17301-1_2016")

**Methods**:

* `#call` - Process all svgmap elements, returns processed document
* `#to_xml` - Process and return XML string

=== Vectory::SvgDocument

Represents an SVG document and handles ID suffixing for uniqueness.

[source,ruby]
----
# Create from SVG content
svg_doc = Vectory::SvgDocument.new(svg_content)

# Apply both ID suffix and index suffix
svg_doc.namespace(index, links, xpath_to_remove, id_suffix: "_ISO_17301-1_2016")
result = svg_doc.content
----

**Constructor**:

* `Vectory::SvgDocument.new(content)` - Create from SVG XML string

**Methods**:

* `namespace(index_suffix, links, xpath_to_remove, id_suffix: nil)` - Apply transformations
** `index_suffix` - Position-based suffix (0, 1, 2...) formatted as 9-digit zero-padded
** `links` - Hash mapping hrefs to targets
** `xpath_to_remove` - XPath for elements to remove (processing instructions)
** `id_suffix` - Optional identity-based suffix for cross-document uniqueness

* `content` - Returns processed SVG as XML string
* `remap_links(map)` - Remap internal links
* `apply_id_suffix(id_suffix)` - Apply ID suffix
* `apply_index_suffix(index)` - Apply index suffix

=== ID Suffixing

SVG IDs are suffixed in two stages:

[source]
----
# Stage 1: ID suffix (cross-document uniqueness)
fig1 → fig1_ISO_17301-1_2016

# Stage 2: Index suffix (multi-svgmap uniqueness)
fig1_ISO_17301-1_2016 → fig1_ISO_17301-1_2016_000000000
----

* **ID suffix** (`id_suffix` parameter): Derived from document/container identity. Optional.
* **Index suffix** (`index_suffix` parameter): Zero-padded position (0, 1, 2... → _000000000, _000000001). Automatically applied.

== See Also

* link:../guides/error-handling/[Error Handling Guide] - Common errors and solutions
* link:../understanding/architecture/[Architecture] - Design patterns
* link:../features/conversion/[Conversion Features] - Conversion details
